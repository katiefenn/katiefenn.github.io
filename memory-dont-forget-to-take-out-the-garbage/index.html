<html data-reactroot="" data-reactid="1" data-react-checksum="-807236822"><head data-reactid="2"><meta name="viewport" content="width=device-width, initial-scale=1.0" data-reactid="3"/><link href="https://fonts.googleapis.com/css?family=Lato:300,300i" rel="stylesheet" data-reactid="4"/><link rel="stylesheet" href="/assets/styles.css" data-reactid="5"/><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/5f3ee6fcdacac39bf058ce91486a9256.png" data-reactid="6"/><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/797414d3fed48ae487f725846fd7d9ce.png" data-reactid="7"/><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/8797f3ffa5c6d05e84c1566476827bda.png" data-reactid="8"/><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/8a4b26f9c023cea2d82b0335d278a181.png" data-reactid="9"/><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/9c334fc0089b97e3dafa42b8359c5100.png" data-reactid="10"/><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/63fbc377c195fa6ec88953f1634d16a5.png" data-reactid="11"/><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/a1e57357c9523878df3152aac35a2505.png" data-reactid="12"/><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/714b71cdd4ff75a68a876645dee7450e.png" data-reactid="13"/><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/d4483449b422b691be6aa882ba6e9bd1.png" data-reactid="14"/><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/0f0a306730b7b0ba56777996a5852e9b.png" data-reactid="15"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/44c9edf2ceed4f79fb9835eaa47fca63.png" data-reactid="16"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/2d94238307594d6066568fd29e0e4af0.png" data-reactid="17"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/0dcda9b7fa830ec49272fdfdfce6f622.png" data-reactid="18"/><link rel="manifest" href="/assets/manifest.json" data-reactid="19"/><meta name="msapplication-TileColor" content="#ffffff" data-reactid="20"/><meta name="msapplication-TileImage" content="/assets/img/a1e57357c9523878df3152aac35a2505.png" data-reactid="21"/><meta name="theme-color" content="#ffffff" data-reactid="22"/></head><body class="_body_161eq_1" data-reactid="23"><header data-reactid="24"><a href="/" data-reactid="25"><h1 class="_main-heading_161eq_244" data-reactid="26">Katie Fenn</h1></a></header><div class="_decoration_161eq_37" aria-hidden="true" data-reactid="27"><div data-reactid="28"><div class="_bubbles_161eq_157" data-reactid="29"></div><div class="_bubbles2_161eq_167 _bubbles_161eq_157" data-reactid="30"></div><div class="_bubbles3_161eq_173 _bubbles_161eq_157" data-reactid="31"></div><div class="_plume1_161eq_195" data-reactid="32"></div><div class="_plume2_161eq_207" data-reactid="33"></div><div class="_mask_161eq_116" data-reactid="34"></div><div class="_gradient_161eq_135" data-reactid="35"></div><div class="_vapour1_161eq_76" data-reactid="36"></div><div class="_shuttle_161eq_55" data-reactid="37"></div><div class="_vapour2_161eq_96" data-reactid="38"></div></div></div><main class="_content_161eq_18" data-reactid="39"><div data-reactid="40"><article class="_article_1ozx9_1" data-reactroot="" data-reactid="1" data-react-checksum="740099291"><h2 id="introduction">Introduction</h2>
<p>Memory is fundamentally important to any computer program. It is an in-demand, finite resource. As devices are given more memory, our apps discover new ways of gobbling it up.</p>
<p><img src="images/interfaces-through-time.png" alt="User interfaces changing over time"></p>
<p>Ten years ago, we saw the beginning of a big change in the way people use the websites we make. Devices like the iPhone and Galaxy mobile phones are now the preferred way of accessing the web. Devices like these are given a fraction of the amount of memory of desktop and laptop computers. And that&#39;s just the high-tech tip of the iceberg - the majority in use around the world have even less.</p>
<p>We&#39;re often told that memory is important, that you need to be mindful of the limitations of these machines. This is absolutely true. But JavaScript does such a remarkable job that, for the most part, we don&#39;t need to worry about memory. Why is that?</p>
<!-- DON'T FORGET TO RECORD! -->
<h3 id="what-is-memory-why-do-we-need-it-">What is memory? Why do we need it?</h3>
<p>Before we can answer that, we need to learn about what memory is and why it is needed.</p>
<p>Memory is used to store instructions and data for computer programs. Early computers like the ENIAC and Colossus were programmed by rewiring their hardware, and consumed data for processing from punched tape. They were fast at breaking encrypted messages, but it would take weeks to re-program them to perform a different task.</p>
<p><img src="images/colossus.jpg" alt="The Colossus computer"></p>
<p>Memory was introduced later to make re-programming computers more convenient. These &quot;stored program computers&quot; could also re-program themselves depending on the data stored in memory.</p>
<p>The memory used by modern-day computers, Random Access Memory, is lightning fast and can read and write data at an imperceptible speed.</p>
<p><img src="images/ram.jpg" alt="A stick of RAM in a computer motherboard"></p>
<p>Web browsers and JavaScript manage memory on our behalf. The areas of memory it manages are called heaps.</p>
<h4 id="memory-and-javascript">Memory and JavaScript</h4>
<p>JavaScript assigns memory for us whenever we declare variables, a fancy name for &quot;a stored value that can change&quot;. Declaration reserves space in memory for our variables. There are four ways of declaring variables:</p>
<p><code>var functionScopedVariable</code></p>
<p><code>let blockScopedVariable</code></p>
<p><code>const blockScopedConstant</code></p>
<p><code>globalVariable = &#39;...&#39;</code></p>
<p>JavaScript reserves areas of memory for declaring variables globally and inside scopes. If the heap is a farm, scopes are fields.</p>
<pre><code>if () {

}

class {

}

while () {

}

for () {

}

switch () {

}

function() {

}
</code></pre><p>Scopes capture the variables outside of functions and blocks and make them available for use inside. Inside of a scope, you can re-declare variable names and protect variables from being written to by other functions. Most importantly, any variables declared and used only within the scope can be discarded when the function ends, allowing the memory they use to be freed.</p>
<p><code>var</code>, <code>let</code> and <code>const</code> tell JavaScript to bind variables to the closest scope. Each one declares variables in different ways, so it&#39;s a great idea to read more about about <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let">how</a> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const">they</a> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var">work</a>. Using these keywords inside of scopes means they can be safely discarded by JavaScript when the function ends. This is good because memory can be freed for variables we no longer need.</p>
<p>The fourth way of declaring a variable has important consequences for our code. When you assign a value to an un-declared variable, a new global variable is created. This is an easy mistake to make, and a common source of bugs. The global scope exists for the lifetime that our website is open in a browser, and as such these variables can never be automatically discarded by JavaScript.</p>
<p>JavaScript is our friend when it comes to the chore of allocating and freeing memory, but unless we are very careful, it will behave in ways we don&#39;t expect.</p>
<p>Once variables are declared, they can be assigned a value. You and I commonly call &quot;=&quot; the &quot;equals sign&quot;, but its proper name in JavaScript is the &quot;assignment operator&quot;.</p>
<p><img src="images/assignment-operators.png" alt="Assignment oprtators in JavaScript"></p>
<p>In fact, all of these operators assign memory. They tell javascript to take a value from the code on the right, and assign it to a memory address described by the variable name on the left.</p>
<h4 id="webassembly-is-the-future">Webassembly is the future</h4>
<p>Webassembly is a new feature for allowing browsers to run languages other than JavaScript in your web pages. It makes it possible to run high-performance code written in languages like C, C++, or Rust in a browser, like this example from Mozilla of the Unreal engine animating a complex 3d scene in real-time.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/TwuIRcpeUWE" frameborder="0" allowfullscreen></iframe>

<p>Check out Mozilla&#39;s article here: <a href="https://hacks.mozilla.org/2017/03/firefox-52-introducing-web-assembly-css-grid-and-the-grid-inspector/">https://hacks.mozilla.org/2017/03/firefox-52-introducing-web-assembly-css-grid-and-the-grid-inspector/</a></p>
<p>Webassembly programs have complete ownership over the memory that they use, and can make their own decisions about how to allocate and free memory. This will give developers the same fine-control of memory, and the performance that comes with it, as native applications.</p>
<p>For more information about webassembly, Lin Clark&#39;s excellent talk from JSConf covers the topic in much more detail!</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/HktWin_LPf4" frameborder="0" allowfullscreen></iframe>

<!-- DON'T FORGET TO RECORD! -->
<h3 id="garbage-collection">Garbage collection</h3>
<p>So far we&#39;ve learned about how memory is allocated. Let&#39;s talk about how memory is freed.</p>
<p>Memory is a finite resource inside the computer. It&#39;s not created or destroyed. JavaScript can only make sure that it is only using as much memory as it needs and free up memory it doesn&#39;t need for re-use.</p>
<p>This is the job of the Garbage Collector.</p>
<p>Before we take a look at that, let&#39;s take a quick look at how memory is managed in a language called C.</p>
<p>C is a language that is used to make many software tools. It is a powerful language that gives you a lot of authority over resources like memory.</p>
<pre><code>int *array = malloc(10 * sizeof(int));
</code></pre><p>The <code>malloc</code> function is used to dynamically allocate memory. In JavaScript we can change the size of objects and arrays at will, but to do this in C we need to use memory management functions. This line of code declares an array with ten items.</p>
<p>Memory is freed using the <code>free</code> function.</p>
<pre><code>free(array);
</code></pre><p>This is a lot of control, but it is also a lot of work to manually allocate and free memory. If you wanted to add more items to the array, you have to repeat this cycle again to allocate more memory. You also have to keep track of all the data your application does and does not need.</p>
<p>Garbage Collection is designed to do take care of memory management for you. And it does an excellent job!</p>
<p>The garbage collector is not one single action. Memory is divided up into two areas: the young generation and the old generation.</p>
<p><img src="images/young-generation-old-generation.png" alt="Diagram of the young generation and old generation"></p>
<p>Variables in JavaScript are mostly short-lived, used for a split-second for a single purpose and then discarded again. The young generation is specially designed to make this as fast as possible so your code is not held up. All new variables are allocated memory here, and organised into half-megabyte pages.</p>
<p>The young generation is partitioned into two semi-spaces. When a semi-space becomes full, a &quot;minor&quot; garbage collection begins. Variables are determined to be &quot;living&quot; or &quot;dead&quot; in a process called a scavenge. &quot;Dead&quot; variables are &quot;unreachable&quot;, they were declared inside a function that has run its course and can no-longer be traced to living data. These variables are discarded. The minor garbage collection can take as little as 1ms, and the more dead data is discarded the more efficient the minor GC is.</p>
<p><img src="images/generation-progression.png" alt="Diagram showing data moving from the young generation to the old generation"></p>
<p>&quot;Living&quot; variables that are still being used are moved to the second semi-space. Any living variables that are still being used after they&#39;ve already been moved once are moved to the &quot;old generation&quot;.</p>
<p>The old generation is designed for longer-lived data. Unlike the young generation, which is a small, agile part of memory, the old generation can expand to a very large size. When the size of the whole heap grows large enough, a major garbage collection begins.</p>
<p>The major GC undertakes a root-and-tip survey of the whole heap to find dead data. This process is called &quot;marking&quot;, and its job is to find data that is not needed and mark it to be reclaimed. The more data that is stored in the older generation, the longer marking takes. This is significant because marking can pause your application, causing it to be unresponsive. Marking the heap can take up to 100ms, or six frames of animation, for very large applications. This latency is one of the major reasons why JavaScript struggles with high-performance applications such as videogames, and why webassembly is so exciting for the future.</p>
<p>V8, Chrome&#39;s implementation of JavaScript, breaks this process up into smaller 1ms chunks so that most applications keep running without any noticeable pauses. The V8 team has recently introduced concurrent marking, allowing around two-thirds of this process to happen in the background while your application keeps running.</p>
<p>The heap is then &quot;swept&quot;, which makes memory usable again. Sweepers also run in the background while your application is running, so that your application can keep running.</p>
<p>Memory is compacted throughout garbage collection. The empty space left in pages of memory means data can be re-organised to make more efficient use of space, and reduces the amount of memory the browser uses.</p>
<p>The garbage collector then is a program running within the browser that frees up memory used by unreachable data. It assumes that all unreachable data is not needed and can be discarded. Problems with memory occur when we fill it up with data we don&#39;t need, or when data never becomes unreachable and memory is not freed. These problems are called memory bloat and memory leaks.</p>
<!-- DON'T FORGET TO RECORD! -->
<h3 id="memory-bloat-and-memory-leaks">Memory Bloat and Memory Leaks</h3>
<h4 id="memory-bloat">Memory Bloat</h4>
<p>Memory bloat is making websites using excessive amounts of assets. HTML, CSS and your JavaScript code are also stored in memory, and Chrome has its own heap of memory to manage these in. It&#39;s important to remember that both heaps contribute to a page&#39;s memory footprint, and a page can experience problems without a single line of JavaScript being written.</p>
<p><img src="images/task-manager.png" alt="The task manager"></p>
<p>Opening the Chrome task manager shows us how much memory each tab is consuming in total. It also breaks down the memory used by just the JavaScript heap to help you diagnose whether your issue is related to your JavaScript code, or whether your page is bloated by your HTML and CSS.</p>
<p>The baseline memory consumption for a &quot;Hello World&quot; page with no JavaScript, no CSS and no images is around 160 megabytes. A crowded page consuming 500 megabytes may not cause an issue on a modern laptop with 16 gigabytes of memory, but it is significant for even a modern smartphone with 2 gigabytes of memory. It becomes critical on older and inexpensive devices that might have only 1 gigabyte of memory or less.</p>
<h4 id="memory-leaks">Memory leaks</h4>
<p><img src="images/terminal-memory-leak.png" alt="A webpage with a terminal memory leak">
When your application steadily accumulates more data in memory than you expect, you have a memory leak. The majority of data created by applications are short-lived and are quickly discarded. Memory leaks occur when your JavaScript code persistently adds more data to the heap than it discards. They are caused by code mistakes that prevent data from becoming unreachable and dying.</p>
<h4 id="accidental-globals">Accidental globals</h4>
<p>Variables created in the global scope are by definition long-lived. This is because the global scope lasts as long as the website is open in the browser. Global variables live forever unless they are manually unset.</p>
<pre><code>function repeat() {
  results = []
  for (var index = 0; index &lt; 100000; index++) {
    results.push({index})
  }
}
</code></pre><p>This function illustrates how easily global variables can be accidentally created. Because the &quot;results&quot; variable is declared without a &quot;var&quot; keyword, the data is created in the global scope and lives forever. Let&#39;s look at what this function does to memory consumption.</p>
<p><img src="images/accidental-globals-profile.png" alt="Memory profile for accidental globals example"></p>
<pre><code>function repeat() {
  var results = []
  for (var index = 0; index &lt; 100000; index++) {
    results.push({index})
  }
}
</code></pre><p>By fixing the global assignment, the garbage collector can free up all the memory assigned in this function after it is called.</p>
<p><img src="images/accidental-globals-fixed-profile.png" alt="Memory profile for accidental globals example - fixed"></p>
<p>Linting tools such as <a href="http://jshint.com/">JShint</a> and <a href="https://eslint.org/">ESlint</a> can be configured to locate undeclared variables, and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">JavaScript&#39;s strict mode</a> makes it impossible to create them.</p>
<h4 id="forgotten-timers">Forgotten timers</h4>
<p>There are other scopes that create long-lived data. Timers and intervals have access to variables in their scope, and because they are needed as long as the timers are active, their scopes stay alive.</p>
<pre><code>function startTimer() {
  var results = []
  return setInterval(() =&gt; {
    console.log(&#39;Tick&#39;)
    results.push(makeLargeString())
  }, 1000)
}
</code></pre><p><img src="images/forgotten-timers-profile.png" alt="Memory profile for forgotten timers"></p>
<p>The overall trend is upwards, the classic mark of a memory leak. The way to fix this is to always remember to clear your timeouts and intervals using <code>clearTimeout()</code> and <code>clearInterval()</code>.</p>
<p><img src="images/forgotten-timers-fixed-profile.png" alt="Memory profile for forgotten timers"></p>
<h4 id="forgotten-event-listeners">Forgotten event listeners</h4>
<p>Event listeners also capture variables in their scope and can keep them alive just like timers.</p>
<pre><code>function createButton() {
  var strings = []
  var button = document.createElement(&#39;input&#39;)
  button.value = &quot;Create large string&quot;
  button.type = &quot;button&quot;
  button.onclick = () =&gt; {
    strings.push(makeLargeString())
  }
  document.body.appendChild(button)
}
</code></pre><p>As long as the event listener is active, its scope is kept alive. Removing unneeded event listeners using <code>removeEventListener()</code> frees up the memory they use.</p>
<h4 id="detached-dom-nodes">Detached DOM nodes</h4>
<p>A common source of memory leaks are orphaned DOM nodes. We use DOM nodes for creating and manipulating HTML elements.</p>
<pre><code>var buttons = new Array(100000)
  .fill(&#39;&#39;)
  .map(() =&gt; document.createElement(&#39;input&#39;))
  .map(button =&gt; Object.assign(button, {value: &#39;Click me&#39;}))
  .map(button =&gt; Object.assign(button, {type: &#39;button&#39;}))
</code></pre><p>This script creates detached DOM nodes, which are useless if they are not added to the DOM tree. Chrome DevTools can help us find these orphaned nodes by taking a memory heap snapshot.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/iaZiu-CSqxs" frameborder="0" allowfullscreen></iframe>

<p>By taking a memory snapshot, and filtering for &quot;Detached&quot; nodes, we can find all the nodes currently in memory that are not in the DOM tree. By clicking on these, we can look for clues to where they can be found. This snapshot lists the object containing our DOM nodes.</p>
</article></div></main><aside class="_profile_161eq_278" data-reactid="41"><h2 data-reactid="42">Profile</h2><p data-reactid="43"><div class="_profilePhotoContainer_161eq_312" data-reactid="44"><img src="/assets/img/05251121f41ec65a69a7c86fa54393aa.jpg" alt="Katie Fenn" class="_profilePhoto_161eq_312" data-reactid="45"/><div class="_overlay_161eq_320" data-reactid="46"></div></div></p><h3 data-reactid="47">Work</h3><p data-reactid="48"><!-- react-text: 49 -->Software Engineer at <!-- /react-text --><a href="https://www.npmjs.com/" data-reactid="50">npm, inc</a></p><h4 data-reactid="51">Formerly:</h4><ul class="_cv_161eq_289" data-reactid="52"><li data-reactid="53"><a href="https://inviqa.com/" data-reactid="54">Inviqa</a></li><li data-reactid="55"><a href="https://skybetcareers.com/our-locations/sheffield" data-reactid="56">SkyBet</a></li><li data-reactid="57"><a href="https://www.canonical.com/" data-reactid="58">Canonical</a></li></ul><h3 data-reactid="59">Upcoming talks</h3><ul class="_talks_161eq_307" data-reactid="60"><li data-reactid="61"><a href="http://scotlandjs.com" data-reactid="62">Scotland JS</a><!-- react-text: 63 --> July 2018<!-- /react-text --></li></ul></aside></body></html>